ðŸ”¹ 1. What is try-except?

Itâ€™s Pythonâ€™s way of saying:
ðŸ‘‰ â€œTry running this code. If an error happens, donâ€™t crash â€” handle it instead.â€

ðŸ”¹ 2. Basic Structure
try:
    # risky code (might throw an error)
    x = int("abc")  
except ValueError:
    print("That was not a number!")


âœ… Output:

That was not a number!

ðŸ”¹ 3. Full Form (All Blocks)
try:
    # code that might fail
    f = open("data.txt", "r")
except FileNotFoundError:
    # handle specific error
    print("File not found!")
else:
    # runs only if no error happens
    print("File opened successfully")
finally:
    # runs no matter what
    print("Done!")

Explanation:

try: â†’ risky code

except: â†’ what to do if error happens

else: â†’ runs if NO error occurs (smart for success cases)

finally: â†’ ALWAYS runs (good for cleanup, closing files, etc.)

ðŸ”¹ 4. What to Remember

Always catch specific errors (ValueError, IndexError) instead of just except: (which hides all bugs).

Use finally for cleanup tasks (closing files, releasing resources).

Use else for code that should run only if no error occurs.

You can catch multiple errors:

try:
    num = int(input("Enter number: "))
    print(10 / num)
except (ValueError, ZeroDivisionError) as e:
    print("Error:", e)

ðŸ”¹ 5. Smart Things to Know

âœ… You can log or print the actual error for debugging:

try:
    x = int("abc")
except ValueError as e:
    print("Error happened:", e)


âœ… Use raise to re-throw an error if you want to stop execution:

try:
    raise ValueError("Invalid value!")
except ValueError as e:
    print("Caught error:", e)
    raise   # re-raises error


âœ… You can even create your own exceptions (useful for real-world apps):

class MyError(Exception):
    pass

try:
    raise MyError("Something went wrong!")
except MyError as e:
    print(e)

ðŸ”¹ 6. Doâ€™s âœ…

Catch specific exceptions (ValueError, KeyError)

Use finally for cleanup (close files, DB connections)

Log error messages (donâ€™t just hide them)

Use else when you want code to run only if no error happens

ðŸ”¹ 7. Donâ€™ts âŒ

Donâ€™t use bare except: â†’ hides bugs, very dangerous.

# âŒ Bad
try:
    risky_code()
except:
    pass   # hides all errors


Donâ€™t catch errors you can prevent with conditions. Example:

# âŒ Bad
try:
    print(my_list[5])
except IndexError:
    print("Index out of range")

# âœ… Better
if len(my_list) > 5:
    print(my_list[5])


Donâ€™t forget that finally always runs â€” even if you return inside try.

ðŸ”¹ 8. Quick Template (Safe Code)
try:
    # risky code
except SpecificError1:
    # handle error 1
except SpecificError2:
    # handle error 2
else:
    # runs if no error
finally:
    # always runs


âœ… In short:
ðŸ‘‰ Use try-except for errors you cannot avoid, conditions for those you can.

| **Error**               | **When it Happens**            | **Example**       | **Fix with try-except**                                                                                                       |
| ----------------------- | ------------------------------ | ----------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| **ValueError**          | Wrong type of value given      | `int("abc")`      | `python\ntry:\n    num = int("abc")\nexcept ValueError:\n    print("Please enter a valid number")\n`                          |
| **TypeError**           | Wrong type operation           | `"5" + 10`        | `python\ntry:\n    result = "5" + 10\nexcept TypeError:\n    print("Type mismatch! Convert before adding")\n`                 |
| **ZeroDivisionError**   | Divide by zero                 | `5/0`             | `python\ntry:\n    x = 5 / 0\nexcept ZeroDivisionError:\n    print("Cannot divide by zero!")\n`                               |
| **IndexError**          | List index out of range        | `[1,2,3][5]`      | `python\ntry:\n    print([1, 2, 3][5])\nexcept IndexError:\n    print("Index out of range")\n`                                |
| **KeyError**            | Dictionary key not found       | `{"a":1}["b"]`    | `python\ntry:\n    my_dict = {"a": 1}\n    print(my_dict["b"])\nexcept KeyError:\n    print("Key not found in dictionary")\n` |
| **AttributeError**      | Invalid method/attribute call  | `5.append(10)`    | `python\ntry:\n    x = 5\n    x.append(10)\nexcept AttributeError:\n    print("Invalid method for this object")\n`            |
| **FileNotFoundError**   | File does not exist            | `open("abc.txt")` | `python\ntry:\n    f = open("abc.txt")\nexcept FileNotFoundError:\n    print("File not found!")\n`                            |
| **ModuleNotFoundError** | Importing missing module       | `import numpyy`   | `python\ntry:\n    import numpyy\nexcept ModuleNotFoundError:\n    print("Module not found. Did you install it?")\n`          |
| **NameError**           | Using variable before defining | `print(x)`        | `python\ntry:\n    print(x)\nexcept NameError:\n    print("Variable not defined")\n`                                          |


ðŸ”‘ Donâ€™t Forget:

âœ… Always catch specific errors (e.g., ValueError, ZeroDivisionError) instead of plain except:.

âœ… Use else for code that should only run if no error happens.

âœ… Use finally for cleanup (close file, disconnect DB).

âš¡ Pro Tip: In real-world apps, combine error handling with logging so you donâ€™t lose track of bugs:

import logging

try:
    x = int("abc")
except ValueError as e:
    logging.error("Error occurred: %s", e)