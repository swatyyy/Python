🔹 1. What is try-except?

It’s Python’s way of saying:
👉 “Try running this code. If an error happens, don’t crash — handle it instead.”

🔹 2. Basic Structure
try:
    # risky code (might throw an error)
    x = int("abc")  
except ValueError:
    print("That was not a number!")


✅ Output:

That was not a number!

🔹 3. Full Form (All Blocks)
try:
    # code that might fail
    f = open("data.txt", "r")
except FileNotFoundError:
    # handle specific error
    print("File not found!")
else:
    # runs only if no error happens
    print("File opened successfully")
finally:
    # runs no matter what
    print("Done!")

Explanation:

try: → risky code

except: → what to do if error happens

else: → runs if NO error occurs (smart for success cases)

finally: → ALWAYS runs (good for cleanup, closing files, etc.)

🔹 4. What to Remember

Always catch specific errors (ValueError, IndexError) instead of just except: (which hides all bugs).

Use finally for cleanup tasks (closing files, releasing resources).

Use else for code that should run only if no error occurs.

You can catch multiple errors:

try:
    num = int(input("Enter number: "))
    print(10 / num)
except (ValueError, ZeroDivisionError) as e:
    print("Error:", e)

🔹 5. Smart Things to Know

✅ You can log or print the actual error for debugging:

try:
    x = int("abc")
except ValueError as e:
    print("Error happened:", e)


✅ Use raise to re-throw an error if you want to stop execution:

try:
    raise ValueError("Invalid value!")
except ValueError as e:
    print("Caught error:", e)
    raise   # re-raises error


✅ You can even create your own exceptions (useful for real-world apps):

class MyError(Exception):
    pass

try:
    raise MyError("Something went wrong!")
except MyError as e:
    print(e)

🔹 6. Do’s ✅

Catch specific exceptions (ValueError, KeyError)

Use finally for cleanup (close files, DB connections)

Log error messages (don’t just hide them)

Use else when you want code to run only if no error happens

🔹 7. Don’ts ❌

Don’t use bare except: → hides bugs, very dangerous.

# ❌ Bad
try:
    risky_code()
except:
    pass   # hides all errors


Don’t catch errors you can prevent with conditions. Example:

# ❌ Bad
try:
    print(my_list[5])
except IndexError:
    print("Index out of range")

# ✅ Better
if len(my_list) > 5:
    print(my_list[5])


Don’t forget that finally always runs — even if you return inside try.

🔹 8. Quick Template (Safe Code)
try:
    # risky code
except SpecificError1:
    # handle error 1
except SpecificError2:
    # handle error 2
else:
    # runs if no error
finally:
    # always runs


✅ In short:
👉 Use try-except for errors you cannot avoid, conditions for those you can.

| **Error**               | **When it Happens**            | **Example**       | **Fix with try-except**                                                                                                       |
| ----------------------- | ------------------------------ | ----------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| **ValueError**          | Wrong type of value given      | `int("abc")`      | `python\ntry:\n    num = int("abc")\nexcept ValueError:\n    print("Please enter a valid number")\n`                          |
| **TypeError**           | Wrong type operation           | `"5" + 10`        | `python\ntry:\n    result = "5" + 10\nexcept TypeError:\n    print("Type mismatch! Convert before adding")\n`                 |
| **ZeroDivisionError**   | Divide by zero                 | `5/0`             | `python\ntry:\n    x = 5 / 0\nexcept ZeroDivisionError:\n    print("Cannot divide by zero!")\n`                               |
| **IndexError**          | List index out of range        | `[1,2,3][5]`      | `python\ntry:\n    print([1, 2, 3][5])\nexcept IndexError:\n    print("Index out of range")\n`                                |
| **KeyError**            | Dictionary key not found       | `{"a":1}["b"]`    | `python\ntry:\n    my_dict = {"a": 1}\n    print(my_dict["b"])\nexcept KeyError:\n    print("Key not found in dictionary")\n` |
| **AttributeError**      | Invalid method/attribute call  | `5.append(10)`    | `python\ntry:\n    x = 5\n    x.append(10)\nexcept AttributeError:\n    print("Invalid method for this object")\n`            |
| **FileNotFoundError**   | File does not exist            | `open("abc.txt")` | `python\ntry:\n    f = open("abc.txt")\nexcept FileNotFoundError:\n    print("File not found!")\n`                            |
| **ModuleNotFoundError** | Importing missing module       | `import numpyy`   | `python\ntry:\n    import numpyy\nexcept ModuleNotFoundError:\n    print("Module not found. Did you install it?")\n`          |
| **NameError**           | Using variable before defining | `print(x)`        | `python\ntry:\n    print(x)\nexcept NameError:\n    print("Variable not defined")\n`                                          |


🔑 Don’t Forget:

✅ Always catch specific errors (e.g., ValueError, ZeroDivisionError) instead of plain except:.

✅ Use else for code that should only run if no error happens.

✅ Use finally for cleanup (close file, disconnect DB).

⚡ Pro Tip: In real-world apps, combine error handling with logging so you don’t lose track of bugs:

import logging

try:
    x = int("abc")
except ValueError as e:
    logging.error("Error occurred: %s", e)